<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="ocean.css" />
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      /* new */
      .example { background-color: #007ebc}
      .example h2 { color: #00394f; font-weight: bold; line-height: 0;}
      .example h1 { color: #fff; font-weight: bold; background-color: #00394f; padding: 10px }

      .codeonly { padding: 1em; background-color: #2b303b }
      .codeonly pre { margin: 0 }

      .remark-code-line-highlighted { background-color: #2d9967; color: white}
      .remark-code-line-highlighted * { color: white !important; }

      .remark-slide-scaler { -webkit-box-shadow: 0 !important; box-shadow: none !important; }
      .remark-slide-container {background-color: #2b303b}
      /* new end */
      .fade {color: #E0E0E0}
      .spanny { padding: 10px; color: white; background-color: #0b1c2e }
      .nopadding { padding: 0 }
      .libs { background-color: #202020}
      .l50 { float: left; width: 50%; }
      .r50 { float: right; width: 50%; }
      .crap pre { border-right: 5px solid #D81F2A; }
      .nice pre { border-right: 5px solid #69F0AE; }

      .corner {border: 5px solid #85C1E9; position: absolute; top: 0px; right: 0px; width: 50%; background-color: #F0F0F0}
      .corner pre {margin: 0; padding: 0}
      .corner.long {height: 300px;}

      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .invert { background-color: black; color: white; }
      .bad { background-color: #AA1914; color: white;}
      .oki { background-color: #3D9972; color: white;}
      .strike { text-decoration: line-through; }
      .lint { background-color: #f3f3f3; }
      .conversation h3 { margin: 17px; font-size: 28px; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Part II

---
class: center, middle, example
# Application aka Service layer

---
## - defines a use case, what the system does

--

## - defines a use case contract (input / output)

--

## - defines transaction boundary

--

## - never ever to be confused with a domain service

---
class: codeonly

.crap[
```java
interface MemberPermissionService {

  void grantPermission(String memberId, String permissionId);

  PermissionsDto listPermissions(String memberId);

}
```
]

--

.crap[
```java
@Transactional
class MemberPermissionServiceImpl implements MemberPermissionService {

  @Override
  public void grantPermission(String memberId, String permissionId) { ... }

  @Override
  public PermissionsDto listPermissions(String memberId) { ... }

}
```
]

---
class: bad

## - tend to grow like hell

--

## - no single entry point

--

## - always blocking

--

## - hard to batch, reorder, cancel, retry, throttle, schedule, serialize, log, validate, decorate...

---
class: codeonly
.nice[
```java
interface Command<T extends Command.R> {
    interface R {
      class Void implements Command.R {
      }
    }
}
```
]

--

.nice[
```java
interface Reaction<C extends Command<R>, R extends Command.R> {
    R react(C $);
}
```
]

--
.nice[
```java
interface Now {
    <C extends Command<R>, R extends Command.R> R execute(C command);
}
```
]
???
a funnel finds and executes appropriate impl for a command using generics

--

.nice[
```java
interface Future {
    <C extends Command<R>, R ...> CompletableFuture<R> schedule(C command);
}```
]

--

.nice[
```java
interface Rx {
    <C extends Command<R>, R ...> Observable<R> observe(C command);
}
```
]

--

.nice[
```java
interface Durable {
    <C extends Command> void enqueue(C command);
}
```
]

---
class: codeonly
.nice[
```java
class GrantPermission implements Command<Command.R.Void> {

    private final String memberId, permissionId;

    public GrantPermission(String memberId, String permissionId) { ... }

    public String memberId() {
        return memberId;
    }

    public String permissionId() {
        return permissionId;
    }
}
```
]

--
.nice[
```java
class GrantPermissionReaction implements Reaction<GrantPermission, Command.R.Void> {

    private final Members members;
    private final Permissions permissions;

    public GrantPermissionReaction(Permissions permissions, Members members) { ... }

    @Override
    public Command.R.Void react(GrantPermissionCommand $) {
        MemberId memberId = new MemberId($.memberId());
        Member member = members.byId(memberId);

        PermissionId permissionId = new PermissionId($.permissionId());
        Permission permission = permissions.byId(permissionId);

        member.grant(permission);
        return new Command.R.Void();
    }
}
```
]

---
class: codeonly
```java
@RestController
class GrantPermissionEndpoint {

    @Autowired
    Now now;

    @PostMapping("/users/{memberId}/permissions")
    Command.R.Void accept(@PathVariable String memberId, @RequestParam String permissionId) {
        GrantPermission grantPermission = new GrantPermission(memberId, permissionId);
        return now.execute(grantPermission);
    }
```

--

```java
    ...

    @Autowired
    Future future;

    future.schedule(grantPermission)
      .thenAccept(System.out::println)
      .thenAccept(...)
```

--

```java
    ...

    @Autowired
    Rx rx;

    rx.observe(grantPermission).subscribe(System.out::println);
```

--

```java
    ...

    @Autowired
    Durable durable;

    durable.enqueue(grantPermission);
```

---
class: codeonly
```java
interface Command<T extends Command.R> {

    default T execute(Now now) {
        return now.execute(this);
    }

    default CompletableFuture<T> schedule(Future future) {
        return future.schedule(this);
    }

    default Observable<T> observe(Rx rx) {
        return rx.observe(this);
    }

    default void enqueue(Durable durable) {
        durable.enqueue(this);
    }
}
```

--
```java
GrantPermission grantPermission = new GrantPermission("memba", "permission");

grantPermission.execute(now);
```

--

```java
grantPermission.schedule(future);
```

--

```java
grantPermission.observe(rx);
```

--

```java
grantPermission.enqueue(durable);
```

---
class: codeonly
```java
class Try<C extends Command<R>, R extends Command.R> implements Command<R> {

    private final C origin;

    private long times = 3;

    public Try(C origin) {
        this.origin = origin;
    }

    public Command<R> origin() {
        return origin;
    }


    public Try<C, R> times(long times) {
        this.times = times;
        return this;
    }

    public long times() {
        return times;
    }
}
```

---
class: codeonly
```java
class TryReaction<C extends Command<R>, R extends Command.R>
                                          implements Reaction<Try<C, R>, R> {

    private final Router router;

    @Override
    public R react(Try<R> $) {

        SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy();
        retryPolicy.setMaxAttempts($.times());

        RetryTemplate template = new RetryTemplate();
        template.setRetryPolicy(retryPolicy);

        return template.execute(context -> {
            Command<R> origin = $.origin();
            Reaction<Command<R>, R> reaction = router.route(origin);
            return reaction.react(origin);
        });
    }
}
```

--

```java
new Try<>(
  new GrantPermission(...))
      .times(5)
      .execute(now);
```

---
class: codeonly
```java
@Component
class Router {

    private final LoadingCache<Type, Reaction> reactions;

    @Autowired
    public Router(ListableBeanFactory beanFactory) {
        this.reactions = Caffeine.newBuilder()
            .build(commandType -> reactions(beanFactory)
                .stream()
                .filter(reaction -> reaction.commandType().isSupertypeOf(commandType))
                .findFirst()
                .orElseThrow(() -> new NoReactionFound(commandType)));
    }

    private Collection<Reaction> reactions(ListableBeanFactory beanFactory) {
        return beanFactory.getBeansOfType(Reaction.class).values();
    }

    public <C extends Command<R>, R extends Command.R> Reaction<C, R> route(C command) {
        return reactions.get(command.type());
    }
}
```

--

```java


interface Reaction<C extends Command<R>, R extends Command.R> {

    R react(C $);

    default TypeToken<C> commandType() {
        return new TypeToken<C>(getClass()) {
        };
    }
}
```

---
class: center, middle
## Bundle advanced functionality into separate objects. Functionality is hidden unless such objects are requested.
### — *Scott Meyers*

---

## .strike[Tend to grow like hell]

--

## .strike[No single entry point]

--

## .strike[Always blocking]

--

## .strike[Hard to batch, reorder, cancel, retry, throttle, schedule, serialize, log, validate, decorate...]

---
class: center, middle
## Centralized Transaction management?

---
class: codeonly
```java
interface Command<T extends Command.R> {

    interface R {
        class Void implements R {

        }
    }

    interface TxFlag {

        TxFlag READ_ONLY = tx -> tx.setReadOnly(true);

        void apply(TransactionTemplate tx);
    }

    default Collection<TxFlag> txFlags() {
        return Collections.emptyList();
    }
}
```

--

```java
class GetMobileNumbers implements Command<GetMobileNumbers, MobileNumbers>

    @Override
    public Collection<TxFlag> txFlags() {
        return ImmutableList.of(TxFlag.READ_ONLY);
    }

}
```

---
class: codeonly
```java
@Component
class TransactionalNow implements Now {

    private final Router router;

    private final PlatformTransactionManager txManager;

    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {

        Reaction<C, R> reaction = router.route(command);

*       TransactionTemplate tx = new TransactionTemplate(txManager);
*       command.txFlags().forEach(flag -> flag.apply(tx));

        R response = tx.execute(txStatus -> reaction.react(command));

        return response;
    }
}
```

---
class: center, middle
## Logging?

---
class: codeonly
```java
@Component
class TransactionalAndLoggingNow implements Now {

    private final Router router;

    private final PlatformTransactionManager txManager;

    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {

        Reaction<C, R> reaction = router.route(command);

        TransactionTemplate tx = new TransactionTemplate(txManager);
        command.txFlags().forEach(flag -> flag.apply(tx));

*       log.info(">>> {}", command.toLogString());
        R response = tx.execute(txStatus -> reaction.react(command));
*       log.info("<<< {}", response.toLogString());

        return response;
    }
}
```

---
class: center, middle
## Logging correlation?

---
class: codeonly
```java
@Component
class CommandCorrelationId {

    private static final String MDC_KEY = "ccid";

    private final AtomicLong counter = new AtomicLong();

    @Value("${unique.node.id}")
    private private String node;


    public void storeForLogging() {
        MDC.put(MDC_KEY, next());
    }

    public void stashFromLogging() {
        MDC.remove(MDC_KEY);
    }

    private String next() {
        return node + counter.incrementAndGet() % 1000;
    }
}
```

---
class: codeonly
```java
@Component
class GrowingNow implements Now {

    private final Router router;

    private final PlatformTransactionManager txManager;

    private final CommandCorrelationId correlationId;

    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {

        Reaction<C, R> reaction = rounter.route(command);

*       correlationId.storeForLogging();

        TransactionTemplate tx = new TransactionTemplate(txManager);
        command.txFlags().forEach(flag -> flag.apply(tx));

        log.info(">>> {}", command.toLogString());
        R response = tx.execute(txStatus -> reaction.react(command));
        log.info("<<< {}", response.toLogString());

*       correlationId.stashFromLogging();

        return response;
    }
}
```

---
class: center, middle
## Refactoring to decorators

---
class: codeonly
```java
@Component
class Pipeline implements Now {

    private final Router router;

    private final PlatformTransactionManager txManager;

    private final CommandCorrelationId correlationId;

    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {
        Now pipe = new Correlable(
                      new Loggable(
                         new Transactional(
                            new Reacting())));

        return pipe.execute(command);
    }
```

--
```java
    private class Correlable implements Now {

        private final Now origin;

        public Correlable(Now origin) {
            this.origin = origin;
        }

        @Override
        public <C extends Command<R>, R extends Command.R> R execute(C command) {
            correlationId.storeForLogging();
            R response = origin.execute(command);
            correlationId.stashFromLogging();
            return response;
        }
    }
```

---
class: codeonly
```java
@Component
class Pipeline implements Now {

    ...

    private class Loggable implements Now {

        private final Logger log = LoggerFactory.getLogger(Loggable.class);

        private final Now origin;

        public Loggable(Now origin) {
            this.origin = origin;
        }

        @Override
        public <C extends Command<R>, R extends Command.R> R execute(C command) {
            log.info(">>> {}", command.toLogString());
            R response = origin.execute(command);
            log.info(">>> {}", command.toLogString());
            return response;
        }
    }

```

--

```java
    private class Transactional implements Now {

        private final Now origin;

        @Override
        public <C extends Command<R>, R extends Command.R> R execute(C command) {
            TransactionTemplate tx = new TransactionTemplate(txManager);
            command.txFlags().forEach(flag -> flag.apply(tx));
            return tx.execute(txStatus -> origin.execute(command));
        }
    }
```

---
class: codeonly
```java
@Component
class Pipeline implements Now {

    ...

    private class Reacting implements Now {

        @Override
        public <C extends Command<R>, R extends Command.R> R execute(C command) {
            Reaction<C, R> reaction = router.route(command);
            return reaction.react(command);
        }
    }

}
```

---
# Commands are also great, because:

--

### - new info can be passed downstream w/o changing the interface

--

### - funnels can read command @Annotations

--

### - flexible composition at command, reaction and funnel side

--

### - favours composion over jdk/javassist/bytebuddy proxying

---
class: center, middle
## Fixing callback hell with CompletableFutures

---
class: codeonly
.crap[
```java
Firebase firebase = new Firebase("https://your-app.firebaseio.com");
Firebase expenses = firebase.child("expenses");

CountDownLatch firebaseWait = new CountDownLatch(1);

AtomicReference<DataSnapshot> snapshot = new AtomicReference<>();
AtomicReference<FirebaseError> exception = new AtomicReference<>();

expenses.addListenerForSingleValueEvent(new ValueEventListener() {
   @Override
   public void onDataChange(DataSnapshot dataSnapshot) {
       snapshot.set(dataSnapshot);
       firebaseWait.countDown();
   }

   @Override
   public void onCancelled(FirebaseError firebaseError) {
       exception.set(firebaseError);
       firebaseWait.countDown();
   }
});

firebaseWait.await(5, TimeUnit.SECONDS);

System.out.println(snapshot.get());
```
]

---
class: codeonly
```java
class RxFirebase {

  private final Firebase root;

  public RxFirebase(Firebase root) {
      this.root = root;
  }
```

--

```java
  public CompletableFuture<DataSnapshot> snapshot(String path) {
      Firebase children = root.child(path);
      CompletableFuture<DataSnapshot> completableFuture = new CompletableFuture<>();
      children.addListenerForSingleValueEvent(new Notify(completableFuture));
      return completableFuture;
  }
```

--

```java
  private class Notify implements ValueEventListener {

      private final CompletableFuture<DataSnapshot> completableFuture;

      public Notify(CompletableFuture<DataSnapshot> completableFuture) {
          this.completableFuture = completableFuture;
      }

      @Override
      public void onDataChange(DataSnapshot dataSnapshot) {
          completableFuture.complete(dataSnapshot);
      }

      @Override
      public void onCancelled(FirebaseError firebaseError) {
          completableFuture.completeExceptionally(firebaseError.toException());
      }
  }
}
```

---
class: codeonly
.nice[
```java
Firebase firebase = new Firebase("https://your-app.firebaseio.com");
```
]

--

.nice[
```java
RxFirebase rxFirebase = new RxFirebase(firebase);
```
]

--

.nice[
```java
CompletableFuture<DataSnapshot> expenses = rxFirebase.snapshot("expenses");
```
]

--

.nice[
```java
DataSnapshot snapshot = expenses.get(5, TimeUnit.SECONDS);
```
]

--

.nice[
```java
System.out.println(snapshot);
```
]

---
# vs.
### - RxJava
### - Spring Reactor
### - Reactive Streams

---
class: center, middle, example
# Validation

---
class: center, middle
## Reject values with wrong type and format asap, before they do harm.
### Preferably, fail fast **before construction**.
???
because others can rely on it.

---
class: center, middle
## Let's see what JPA/Hibernate want you to do...


---
class: codeonly
.crap[
```java
class User {

    @Email
    private String email;                           // not really an email, liar

    @Strong
    private String password;                        // might not be strong

    private LocalDateTime registeredAt;

    public User(String email, String password) {
        this.email = email;
        this.password = password;
    }

    public void changePassword(String newPassword) {
        this.password = newPassword;
    }

    public void register() {
        this.registeredAt = LocalDateTime.now();
    }

    public String email() {
        return email;
    }
}
```
]

---

class: codeonly
.crap[
```java
class RegisterNewUserReaction implements Reaction<RegisterNewUser, Command.R.Void> {

    private final WelcomeNotification notification;

    @Override
    public Command.R.Void react(RegisterNewUser $) {
        User user = makeUser($);                    // broken at this point
```
]

--

.crap[
```java
        user.register();                            // still broken
```
]

--

.crap[
```java
        users.persist(user);
```
]

--

.crap[
```java
        welcomeNotification.schedule(user);         // what if I send notification before PERSIST()?

        return new Command.R.Void();
    }
}
```
]

--

.crap[
```java
class WelcomeNotification {
    void schedule(User user) {
        user.email();                               // accepts lies and (hopefully) booms
    }
}
```
]
???
by default, Hibernate validates during PERSIST :-)

---
class: codeonly
```java
class Email {

  private final String text;

  public Email(Email.Unvalidated email) {
      checkArgument(email.isValid(), "%s is not an RFC-5322 compliant email.", text);
      this.text = text;
  }

  public Email(String text) {
      this(new Email.Unvalidated(text));
  }

  ...
```
---
class: codeonly
```java
class Email {

  ...

  static class Unvalidated {

      private static final String LOCAL_PART = "^[\\w!#$%&’*+/=?`{|}~^-]+(?:\\.[\\w!#$%&’*+/=?`{|}~^-]+)*";
      private static final String AT_SIGN = "@";
      private static final String HOSTNAME_FOLLOWED_BY_DOT = "(?:[a-zA-Z0-9-]+\\.)+";
      private static final String COUNTRY_CODE = "[a-zA-Z]{2,6}";
      private static final String END_OF_LINE = "$";

      private final Pattern RFC_5322 = compile(
              LOCAL_PART + AT_SIGN + HOSTNAME_FOLLOWED_BY_DOT + COUNTRY_CODE + END_OF_LINE);

      private String text;

      public Unvalidated(String text) {
          this.text = text;
      }

      public boolean isValid() {
          return RFC_5322.asPredicate().test(text);
      }

      @Override
      public String toString() {
          return text;
      }
  }

}
```

---
class: codeonly
```java
@Override
public Command.R.Void react(RegisterNewUser $) {

   Email.Unvalidated email = new Email.Unvalidated($.email()));
   if (!email.isValid()) {
     throw new ValidationConstraintViolated("Dooh! The email " + $.email() + " is not valid");
   }

   User user = makeUser(new Email($.email()), ...);
   ...
}
```

--

```java
static class Unvalidated {

   ...

   public Optional<Email> valid() {
       return isValid() ? Optional.of(new Email(rawText)) : Optional.empty();
   }
}
```

---
class: codeonly
```java
@Override
public Command.R.Void react(RegisterNewUser $) {

   Email email = new Email.Unvalidated($.email())
                     .valid()
                     .orElseThrow(() -> new ValidationConstraintViolated("Dooh! ..."));

   User user = makeUser(email, ...);
   ...
}
```

--

```java
@Override
public Command.R.Void react(RegisterNewUser $) {

  Email email = new Email.Unvalidated($.email())
                    .valid()
                    .orElseThrow(() -> new ValidationConstraintViolated("o_O"));

  Password password = new Password($.password());
  if (password.isWeak()) {
      throw new ValidationConstraintViolated("Weak password, sorry fella");
  }

  ...

  return new Command.R.Void();
}
```

---
class: center, middle
## Let's avoid branching and make code more declarative

---
class: codeonly
```java
@Override
public Command.R.Void react(RegisterNewUser $) {

  Email.Unvalidated email = new Email.Unvalidated($.email());
  Password password = new Password($.password());
```

--

```java
  Preconditions preconditions = new Preconditions();
```

--

```java
  preconditions
          .whenNot(email, Email.Unvalidated::isValid)
          .then("Sorry man, email (%s) is completely wrong.");
  preconditions
          .when(password, Password::isWeak)
          .then("Password is too weak. Make it secure by adding some weird characters.");
```

--

```java
  preconditions.check();

  ...

  return new Command.R.Void();
}
```

---
class: codeonly
```java
class Preconditions {

    <T> Constraint when(T value, Predicate<T> predicate) {}

    <T> Constraint whenNot(T value, Predicate<T> predicate) {}

    void check() {}

}
```

--

```java
class Constraint<T> {

    private final T item;
    private final Predicate<T> predicate;

    private String failureMessage;

    public Constraint(T item, Predicate<T> predicate) {
        this.item = item;
        this.predicate = predicate;
    }

    void then(String failureMessage) {
        this.failureMessage = failureMessage;
    }

    boolean isViolated() {
        return predicate.test(item);
    }

    String message() {
        return failureMessage.replaceAll("%s", item.toString());
    }

}
```

---
class: codeonly
```java
class Preconditions {

    private final Collection<Constraint> constraints = new LinkedList<>();

    @Override
    public <T> Constraint whenNot(T value, Predicate<T> predicate) {
        return when(value, predicate.negate());
    }
```

--

```java
    @Override
    public <T> Constraint when(T value, Predicate<T> predicate) {
        Constraint<T> constraint = new Constraint<>(value, predicate);
        constraints.add(condition);
        return constraint;
    }
```

--

```java
    @Override
    public void check() {
        constraints.stream()
                .filter(Constraint::isViolated)
                .findFirst()
                .ifPresent(constraint -> {
                    throw new ValidationConstraintViolated(constraint.message());
                });

    }
}
```

---
class: center, middle
## Adding business validation
### (email uniqueness check)

---
class: codeonly
```java
class Email {

    private final String text;

    public Email(String text) {
        ...
    }

    ...
```

--

```java
    interface Uniqueness {
      boolean guaranteed(Email email);
    }
}
```

--

```java
@Repository
interface Users {
    Optional<User> byEmail(Email email);
}
```

--

```java
@Component
class AmongUsers implements Email.Uniqueness {

    private final Users users;

    @Override
    public boolean guaranteed(Email email) {
        return !users.byEmail(email).isPresent();
    }
}
```

---
class: codeonly
```java
private final Email.Uniqueness uniqueness;

@Override
public Command.R.Void react(RegisterNewUser $) {

  Email.Unvalidated email = new Email.Unvalidated($.email());
  Password password = new Password($.password());

  Preconditions preconditions = new Preconditions();
  preconditions
          .whenNot(email, Email.Unchecked::isValid)
          .then("Sorry man, email (%s) is completely wrong.");
  preconditions
*         .whenNot(email.valid().get(), uniqueness::guaranteed)          // lazy needed
*         .then("Argh, email is taken by some hacker.");
  preconditions
          .when(password, Password::isWeak)
          .then("Password is too weak. Make it secure by adding some weird characters.");

  preconditions.check();

  ...

  return new Command.R.Void();
}
```

---
class: codeonly
```java
private final Email.Uniqueness uniqueness;

@Override
public Command.R.Void react(RegisterNewUser $) {

  Email.Unvalidated email = new Email.Unvalidated($.email());
  Password password = new Password($.password());

  Preconditions preconditions = new Preconditions();
  preconditions
          .whenNot(() -> email, Email.Unchecked::isValid)
          .then("Sorry man, email (%s) is completely wrong.");
  preconditions
          .whenNot(() -> email.valid().get(), uniqueness::guaranteed)
          .then("Argh, email is taken by some hacker.");
  preconditions
          .when(() -> password, Password::isWeak)
          .then("Password is too weak. Make it secure by adding some weird characters.");

  preconditions.check();

  ...

  return new Command.R.Void();
}
```

---
class: codeonly
```java
class Preconditions {

    <T> Constraint when(Supplier<T> value, Predicate<T> predicate) {}

    <T> Constraint whenNot(Supplier<T> value, Predicate<T> predicate) {}

    void check() {}

}
```

--

```java
class Constraint<T> {

    private final Supplier<T> item;
    private final Predicate<T> predicate;

    private String failureMessage;

    public Constraint(Supplier<T> item, Predicate<T> predicate) {
        this.item = item;
        this.predicate = predicate;
    }

    void then(String failureMessage) {
        this.failureMessage = failureMessage;
    }

    boolean isViolated() {
        return predicate.test(item.get());
    }

    String message() {
        return failureMessage.replaceAll("%s", item.get().toString());
    }

}
```

---
class: codeonly
```java
class Preconditions {

    private final Collection<Constraint> constraints = new LinkedList<>();

    @Override
    public <T> Constraint whenNot(Supplier<T> value, Predicate<T> predicate) {
        return when(value, predicate.negate());
    }
```

```java
    @Override
    public <T> Constraint when(Supplier<T> value, Predicate<T> predicate) {
        Constraint<T> constraint = new Constraint<>(value, predicate);
        constraints.add(constraint);
        return constraint;
    }

    // everythige else stays absolutely the same
}
```


---
class: center, middle
## Some more examples

---
class: codeonly
```java
preconditions
        .whenNot(() -> $.affiliateId(), Optional::isPresent)
        .then("Omg, missing affiliate id!");

```

--

```java


class TooShort implements Predicate<Password> {

    @Override
    public boolean test(Password pw) {
        return pw.text().length() < 10;
    }
}

class TooEasyToGuess implements Predicate<Password> {

    @Override
    public boolean test(Password pw) {
        return pw.text().equals("qwerty123");
    }
}

preconditions
        .when($.password(), new TooShort().or(new TooEasyToGuess()))
        .then("Pick a better password, dude");
```

---
class: center, middle
# ?
???
- how to make sure that whenever password is created, it's always strong?

---
class: center, middle
## Do we need Hibernate Validator aka JSR-349 RI?

---

## - validation is not a rocket science

--

## - HV works out-of-the-box with stateful Java Beans

--

## - HV requires bloody getters for method validation

--

## - HV does not work well with immutables.github.io

--

## - HV is mess when it comes to non-Java Beans

---
class: codeonly
.crap[
```java
class Email {

    private final String text;

    public Email(String text) {
      ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
      ExecutableValidator validator = factory.getValidator().forExecutables();
      Constructor<Email> constructor = getConstructorIfAvailable(Email.class, String.class);

      validator
              .validateConstructorParameters(constructor, new Object[]{text})
              .stream()
              .findAny()
              .ifPresent(violation -> {
                  throw new IllegalArgumentException(violation.getMessage());
              });

      this.text = rawText;
    }
}
```
]
???
essentially, it is out of date. Could support Java 8 method and const references instead of reflection

---
class: center, middle
## And tolerable for stateful Java Beans...
### (but your app is not only a set of stateful Java Beans, hopefully)

---
class: codeonly
```java
@Documented
@Constraint(validatedBy = { ElonMuskValidator.class })
@Target({ TYPE })
@Retention(RUNTIME)
public @interface ElonMusk {

    String message() default "{com.devchampions.ElonMusk.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };
}
```

--

```java
class ElonMuskValidator implements ConstraintValidator<ElonMusk, Hiree> {

    @Override
    public void initialize(ElonMusk annotation) {}

    @Override
    public boolean isValid(Hiree hiree, ConstraintValidatorContext context) {
        if (hiree == null) {
            return true;
        }
        return hiree.hasInvented(Invention.SPACEX);
    }
}
```

---
class: codeonly
```java
class ApplyForDreamJob implements Command<Command.R.Void> {

  @ElonMusk
  private Hiree hiree;

}
```

```java
class Validable implements Now {

  private final Validator validator;

  Validable() {
    this.validator = Validation
                          .buildDefaultValidatorFactory()
                          .getValidator();
  }
```

--

```java
  public <C extends Command<R>, R extends Command.R> R execute(C command) {}
    Set<ConstraintViolation<C>> violations = validator.validate(command);
    if (!violations.isEmpty()) {
        throw new ConstraintViolationException("Boom!", violations);
    }
  }


}
```

---
class: center, middle, example
# Persistence

---
# DAO aka Data Access Object (2001)

--

### - Encapsulates access to data behind a well-defined interface

--

### - Makes client code persistence agnostic (db, ldap, rest...)

--

### - Don't do this at home:

---
class: codeonly
.crap[
```java
interface CustomerDAO {

  UUID insert(Customer customer);

  UUID insert(CustomerDTO customer);

  Customer insert(String personalId, String fullName);

  boolean saveOrUpdate(Customer customer);

  boolean updateFullname(Customer customer, String newFullName);

  boolean delete(Customer customer);

  boolean deleteByPersonalId(String personalId);

  Customer findByPersonalId(String personalId);

  Collection<Customer> findAll();

  Collection<PhoneNumber> findMobileNumbers(String personalId);

  void merge(Customer detached);

  ...
}
```
]

---
class: center, middle
# **Repository** mediates between the domain and data mapping layers using a **collection-like interface** for accessing domain objects.
### — *Fowler, PoEAA*

---
class: codeonly
.crap[
```java
interface CustomerDAO {
  UUID insert(Customer customer);
  UUID insert(CustomerDTO customer);
  Customer insert(String personalId, String fullName);
  boolean saveOrUpdate(Customer customer);
  boolean updateFullname(Customer customer, String newFullName);
  boolean delete(Customer customer);
  boolean deleteByPersonalId(String personalId);
  Customer findByPersonalId(String personalId);
  Collection<Customer> findAll();
  Collection<PhoneNumber> findMobileNumbers(String personalId);
  void merge(Customer detached);
  ...
}
```
]

--

```java
@VanillaImplementation
interface Customers {
  void add(Customer customer);
  void delete(Customer customer);
  Collection<Customer> all();
}
```

--

```java
@InRealWorldWeAlsoNeedCriteria
interface Customers {
  void add(Customer customer);
  void delete(Customer customer);
  Collection<Customer> allBy(Criteria criteria);
  Collection<Customer> singleBy(Criteria criteria);
}
```


---
class: center, middle
## Repository is not resposible for assigning ids
### (generate ids upon entity creation)

---
class: codeonly
.crap[
```java
class Account {

    @GeneratedValue(strategy= GenerationType.AUTO)
    private UUID id;

    private String iban;

    public Account(String iban) {
        this.iban = iban;
    }
}
```
]

--

.crap[
```java
class DontDoThisAtHomeRepository implements Repository<Account> {

    public UUID add(Account account) {
      entityManager.persits(account);
      return account.id();
    }
}
```
]

--

```java
Account offshore = new Account("DZ4000400174401001050486");
```

--

```java
Collection<Account> accounts = new HashSet<>();
accounts.add(offshore);
```

--

```java
accountRepository.add(offshore); // generates UUID
```

--
```java
accounts.contains(offshore)      // false
```

---
class: center, middle
## Use pre-generated UUIDs
### (consider stealing Cassandra's TimeUUID)

---
class: codeonly


.nice[
```java
interface Customers extends Repository<Customer> {
    void add(Customer customer);
}
```
]

.nice[
```java
@Entity
class Customer {

    @Id
    private UUID id = UUID.randomUUID();

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        Customer other = (Customer) obj;
        return Objects.equals(this.id, other.id);
    }
```
]
???
now you can use the uuds before the persistance

---
class: right, middle
### .fade[For each type of object that needs global access, create an object that can] provide the illusion of an in-memory collection .fade[ of all objects of that type. Set up access through a well-known global interface. Provide methods to add and remove objects, which will encapsulate the actual insertion of removal of data in the data store. Provide methods that select objects based on some criteria and return fully instantiated objects or collections of objects whose attribute values meet the criteria, thereby encapsulating the actual storage and query technology. ]Provide repositories only for aggregate roots .fade[that actually need direct access. Keep the client focused on the model, delegating all object storage and access to the Repositories.]
### — *Evans, DDD*

---
class: center, middle
# An aggregate is a cluster of domain objects that can be treated as a single unit. Any references from outside the aggregate should only go to the aggregate root.
### — *Fowler, Bliki*

---
class: center, middle
# Aggregate root ensures consistency of an aggregate.

---
class: codeonly
```java
@Entity
class BankAccount {

    @Id
    private UUID id = UUID.randomUUID();

    @Enumerated(EnumType.STRING)
    private Status status = Status.OPEN;

    @Embedded
    private WithdrawalLimit withdrawalLimit = WithdrawalLimit.DEFAULT;

    @ElementCollection
    @CollectionTable(name = "BANK_ACCOUNT_TX")
    @OrderColumn("INDEX")
    private List<Transaction> transactions = new ArrayList<>();

    @Version
    private long version;

    ...

```

```java
@Embeddable
class Transaction {

    private DecimalNumber amount;

    private LocalDateTime bookedAt = LocalDateTime.now();

    @Enumerated(EnumType.STRING)
    private TransactionType type;

    ...
}
```

---
class: codeonly
```java
@Entity
class BankAccount {

    ...

    private List<Transaction> transactions = new ArrayList<>();

```

--

```java
    public DecimalNumber balance() {
        DecimalNumber totalDeposited = transactions.stream()
                .filter(tx -> tx.type().equals(DEPOSIT))
                .map(Transaction::amount)
                .reduce(new Const(0), DecimalNumber::plus);

        return transactions.stream()
                .filter(tx -> tx.type().equals(WITHDRAWAL))
                .map(Transaction::amount)
                .reduce(totalDeposited, DecimalNumber::minus);
    }
```

--

```java
    public Transaction deposit(DecimalNumber amount) {
        Domain.ensure(!isClosed(), "Cannot deposit funds to closed account.");

        Transaction depositTx = new Transaction(DEPOSIT, amount);
        transactions.add(depositTx);

        return depositTx;
    }
```

--

```java
    private boolean isClosed() {
        return status.equals(Status.CLOSED);
    }

    public void close() {
        status = Status.CLOSED;
    }
```

---
class: codeonly
```java
@Entity
class BankAccount {

    ...

    public Transaction withdraw(DecimalNumber amount) {
        Domain.ensure(!isClosed(), "Cannot withdraw funds from closed account.");

        Transaction withdrawalTx = new Transaction(WITHDRAWAL, amount);
        transactions.add(withdrawalTx);

        ensurePositiveBalance();
        ensureDailyWithdrawalLimitIsNotExceeded();

        return withdrawalTx;
    }

    private void ensurePositiveBalance() {
        Domain.ensure(balance().isPositive(),
          "Cannot withdraw more funds than available on your account.");
    }

```

---
class: codeonly
```java
@Entity
class BankAccount {

    ...

    private void ensureDailyWithdrawalLimitIsNotExceeded() {
        DecimalNumber dailyLimit = withdrawalLimit.dailyLimit();
        DecimalNumber withdrawnToday = totalWithdrawn(now());
        boolean dailyLimitExceeded = withdrawnToday.isGreaterThan(dailyLimit);
        Domain.ensure(!dailyLimitExceeded,
          "Cannot withdraw funds. Daily withdrawal limit (%s) reached.", dailyLimit);
    }

    private DecimalNumber totalWithdrawn(LocalDate bookedOn) {
        return transactions.stream()
                .filter(tx -> tx.type().equals(WITHDRAWAL))
                .filter(tx -> tx.bookedAt().toLocalDate().isEqual(bookedOn))
                .map(Transaction::amount)
                .reduce(new Const(0), DecimalNumber::plus);
    }
}
```

---
## BankAccount gives the following guarantees:

--

### - there is no way to create withdraw/deposit a CLOSED account

--
### - there is no way to withdraw more funds than available

--

### - there is no way to withdraw more funds than allowed by a daily limit

--

### - returned Transactions fulfill all rules imposed by BankAccount
???
PLEASE MAKE THE IMMUTABLE!!!

--

### - an aggregate is protected by a single optimistic lock

--

### - lifecycle of Transactions is bound to BankAccount

---
class: bottom, middle
background-image:url(thrones_aggregate.jpg)
background-size: 50%
???
Effective Aggregate Design by Vaughn Vernon (https://vaughnvernon.co/?p=838)

---
class: center, middle
# Aggregate root defines transactional boundaries.
### ...and can only be designed after careful transactional analysis.

---
class: codeonly
```java
@Entity
@GuardedByOptimisticLock
public class Customer extends DomainEntity {

    @Embedded
    @AttributeOverride(name = "text", column = @Column(name = "EMAIL_ADDRESS"))
    private Email emailAddress;

    @Embedded
    @AttributeOverride(name = "text", column = @Column(name = "PASSWORD"))
    private Password password;

    @Embedded
    @AttributeOverride(name = "text", column = @Column(name = "ADDRESS"))
    private Address address;

    public Customer(Email emailAddress, Password password) {
        this.emailAddress = emailAddress;
        this.password = password;
    }

    private Customer() {
    }

    public void relocateTo(Address address) {
        this.address = address;
    }

    public void changePassword(Password newPassword) {
        this.password = newPassword;
    }

}
```

---
class: codeonly

```java
@Throws(org.springframework.orm.ObjectOptimisticLockingFailureException)
void boom() {

    Customer customer = new Customer(
      new Email("hello@devchampions.com"),
      new Password("qwerty123"));

    executeInTx(() -> entityManager.persist(customer));

    CyclicBarrier coordinator = new CyclicBarrier(2);

    new Thread(() ->
        executeInTx(() ->
            entityManager
              .find(Customer.class, customer.id())
              .relocateTo(new Address("New York, Central Park"));
            coordinator.await();
        })
    ).start();

    new Thread(() ->
        executeInTx(() ->
            entityManager
              .find(Customer.class, customer.id())
              .changePassword(new Password("whatever"));
            coordinator.await();
        })
    ).start();
}
```

---
class: center, middle
# Map aggregates by identity, not by pointer to avoid risk of modifying more than one aggregate per transaction.
### (concurrency exceptions can reach the point where the system becomes unusable)

---
class: codeonly
```java
@Entity
class TravisLog extends DomainEntity {

    @ElementCollection
    @CollectionTable(name = "TRAVIS_LOG_ENTRIES")
    private Collection<Entry> entries = new ArrayList<>();

    private LocalDateTime archivedAt;

    public void write(Entry entry) {
      this.entries.add(entry);
    }

    public void archive() {
        this.archivedAt = LocalDateTime.now();
    }
}
```

--

```java
@Entity
class Travis extends DomainEntity {

    @ManyToOne
    private TravisLog log;

    @OneToMany
    private Collection<TravisRepository> repositories = new ArrayList<>();

    public void manage(GitHubRepository gitHubRepository) {
        TravisRepository repository = new TravisRepository(gitHubRepository);
        repositories.add(repository);
        log.write(new NewRepositoryLogEntry(repository.id()))
    }
```

---
class: codeonly
```java
@Throws(org.springframework.orm.ObjectOptimisticLockingFailureException)
void boom() {

    Travis travis = new Travis();
    TravisLog travisLog = new TravisLog();
    GitHubRepository gitHubRepository = new GitHubRepository();

    executeInTx(() ->
      persist(travis, travisLog, gitHubRepository);
    );

    CyclicBarrier coordinator = new CyclicBarrier(2);

    new Thread(() ->
        executeInTx(() ->
            entityManager
              .find(Travis.class, travis.id())
              .manage(gitHubRepository);
            coordinator.await();
        })
    ).start();

    new Thread(() ->
        executeInTx(() ->
            entityManager
              .find(TravisLog.class, travisLog.id())
              .archive();
            coordinator.await();
        })
    ).start();
}
```

---
class: codeonly

```java
@Entity
class Travis extends DomainEntity {

    @ManyToOne
    private TravisLog log;

    @OneToMany
    private Collection<TravisRepository> repositories = new ArrayList<>();

    public void manage(GitHubRepository gitHubRepository) {
        TravisRepository repository = new TravisRepository(gitHubRepository);
        repositories.add(repository);
        log.write(new NewRepositoryLogEntry(repository.id()));
    }
```

--

```java
@Entity
class Travis extends DomainEntity {

*   @Embedded
*   private TravisLogId logId;

    @OneToMany
    private Collection<TravisRepository> repositories = new ArrayList<>();

    public void manage(GitHubRepository gitHubRepository) {
        TravisRepository repository = new TravisRepository(gitHubRepository);
        repositories.add(repository);
*       log.write(new NewRepositoryLogEntry(repository.id())); // woohoo, it's impossible now.
    }
```

---
background-image:url(eventual.jpg)
background-size: 50%

---
class: codeonly
```java
@Entity
class Travis extends DomainEntity {

    @Embedded
    private TravisLogId logId;

    @OneToMany
    private Collection<TravisRepository> repositories = new ArrayList<>();

    public void manage(GitHubRepository gitHubRepository) {
        TravisRepository repository = new TravisRepository(gitHubRepository);
        repositories.add(repository);
*       DomainEvents.durable().publish(new NewRepositoryAdded(logId, repository.id()));
    }
```

--

```java
@RunInASeparateTransaction
@RetryBeforePanic(times = 3)
class WriteNewRepositryLogEntry implements SideEffect<NewRepositoryAdded> {
    @Override
    public void occur(NewRepositoryAdded $) {
        TravisLog log = logs.byId($.logId());
        log.write(new NewRepositoryLogEntry($.newRepositoryId()));
    }
}
```

---
class: center, middle, example
## an example of
# ephemeral domain events

---
class: codeonly

```java
interface DomainEvent {

    default Type type() {
        return this.getClass();
    }
}
```

--

```java
interface SideEffect<E extends DomainEvent> {

    void occur(E $);

    default TypeToken<E> eventType() {
        return new TypeToken<E>(getClass()) {
        };
    }
}
```

--

```java
interface DomainEvents {

    void publish(DomainEvent event);

    static DomainEvents ephemeral() {
        return EphemeralDomainEvents.instance();
    }

    static DomainEvents durable() {
        return DurableDomainEvents.instance();
    }
}
```

---
class: codeonly
```java
class EphemeralDomainEvents implements DomainEvents {

    private static DomainEvents instance;

    @WhyWorkStealing("http://bit.ly/forkjoinj8")
    private final ExecutorService executor = Executors.newWorkStealingPool();

    private final TransactionTemplate tx;

    private final SideEffects sideEffects;

    public EphemeralDomainEvents(SideEffects sideEffects, TransactionTemplate tx) {
        EphemeralDomainEvents.instance = this;
        ...
    }
```

--

```java
    public void publish(DomainEvent event) {
        sideEffects.byEvent(event)
                .forEach(sideEffect -> inFuture(inTx(txStatus -> sideEffect.occur(event))));
    }

    private CompletableFuture<Void> inFuture(Runnable runnable) {
        return CompletableFuture.runAsync(runnable, executor);
    }

    private Runnable inTx(Consumer<TransactionStatus> consumer) {
        return () -> tx.execute(status -> { consumer.accept(status); return empty(); });
    }
```

--

```java
    public static DomainEvents instance() {
        return checkNotNull(instance, "Ephemeral domain events have not been initialized yet.");
    }
}
```

---
class: codeonly
```java
class SideEffects {

    private final LoadingCache<Type, Collection<SideEffect>> cachedSideEffects;

    public SideEffects(ListableBeanFactory beanFactory) {
        this.cachedSideEffects = Caffeine.newBuilder()
                .build(eventType -> sideEffects(beanFactory)
                        .stream()
                        .filter(sideEffect -> sideEffect.eventType().isSupertypeOf(eventType))
                        .collect(toList()));

    }

    private Collection<SideEffect> sideEffects(ListableBeanFactory beanFactory) {
        return beanFactory
                .getBeansOfType(SideEffect.class)
                .values();
    }

    public Collection<SideEffect> byEvent(DomainEvent event) {
        return cachedSideEffects.get(event.type());
    }
}
```

---
class: center, middle, example
# Stability Patterns
## Shed Load, Bulkheads, Timeouts and Circuit Breakers

---
class: center, middle
## Load Shedding and Bulkheads with Hystrix

---
class: codeonly
```java
@Component
class Pipeline implements Now {

    ...

    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {
        Now pipe =
*               new ConcurrencyLimited(
                        new Correlable(
                                new Loggable(
                                        new Transactional(
                                                new Reacting())))));

        return pipe.execute(command);
    }
```

---
class: codeonly
```java
private class ConcurrencyLimited implements Now {

       private final Now origin;

       Hystrix(Now origin) {
           this.origin = origin;
       }

       @Override
       public <C extends Command<R>, R extends Command.R> R execute(C command) {

         HystrixCommand.Setter commandOptions = hystrixOptions(command);
         HystrixCommand<R> hystrixCommand = new HystrixCommand<R>(commandOptions) {
               @Override
               protected R run() throws Exception {
                   return origin.execute(command);
               }
         };
         return hystrixCommand.execute();
       }
```
--

```java
       private HystrixCommand.Setter hystrixOptions(Command command) {
          int concurrencyLimit = command.concurrencyLimit().orElse(10);
          return HystrixCommand.Setter
                .withGroupKey(HystrixCommandGroupKey.Factory.asKey(command.name()))
                .andCommandKey(HystrixCommandKey.Factory.asKey(command.name()))
                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
                      .withExecutionIsolationStrategy(SEMAPHORE)
                      .withExecutionIsolationSemaphoreMaxConcurrentRequests(concurrencyLimit));
        }
}
```

---
class: codeonly
```java
IntStream.range(1, 10).parallel().forEach(i -> {
      logOnError(()-> new Foo().execute(now));
      logOnError(()-> new Bar().execute(now));
});
```

--
```java
@TwoOutOfTenCommandsWillEndWith
com.netflix.hystrix.exception.HystrixRuntimeException:
  Foo could not acquire a semaphore for execution and no fallback available.
```

--

```java
public interface Reaction<C extends Command<R>, R extends Command.R> {

    R react(C $);

    default R fallback(C $) {
        throw new UnsupportedOperationException("No fallback available.");
    }

    ...
}
```

--

```java
class GetTotalLikesReaction implements Reaction<GetTotalLikes, TotalLikes> {

    @Override
    public TotalLikes fallback(GetTotalLikes $) {
        return new TotalLikes(10000000);
    }
```

---
class: codeonly
```java
private class HystrixGuarded implements Now {
    @Override
    public <C extends Command<R>, R extends Command.R> R execute(C command) {
        Reaction<C, R> reaction = router.route(command);

        HystrixCommand.Setter commandOptions = hystrixOptions(command);
        HystrixCommand<R> hystrixCommand = new HystrixCommand<R>(commandOptions) {
            @Override
            protected R run() throws Exception {
                return reaction.react(command);
            }

            @Override
            protected R getFallback() {
                return reaction.fallback(command);
            }

        };

        return hystrixCommand.execute();
    }
}
```

--
```java
@Override
public <C extends Command<R>, R extends Command.R> R execute(C command) {
    Now pipe =
            new Correlable(
                    new Loggable(
                            new Transactional(
                                    new HystrixGuarded())));

    return pipe.execute(command);
}
```

---

class: codeonly
```java
IntStream.range(1, 10).parallel().forEach(i -> {
      logOnError(()-> new GetTotalLikes().execute(now));
      logOnError(()-> new GetTotalShares().execute(now));
});
```

--
```java
@GetTotalLikesWillAlwaysSucceed
@TwoOutOfTenCommandsWillEndWith
@AllExceptionLeadToFallbackExcept(HystrixBadRequestException.class)
com.netflix.hystrix.exception.HystrixRuntimeException:
  GetTotalShares could not acquire a semaphore for execution and no fallback available.
```

---
class: center, middle
# Timeouts


---
class: codeonly
```java
@AllCommandsRunInTheCallingThread
@AllCallingThreadsWillBlockSoon
class GetTotalLikesReaction implements Reaction<GetTotalLikes, TotalLikes> {

    @Override
    public TotalLikes react(GetTotalLikesReaction $) {
      try {
          TimeUnit.SECONDS.sleep(30);
      } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
      }
    }

```

--
```java
@NowAllCommandsRunInASeparateThreadPool
@BulkheadsOnSteroids
private HystrixCommand.Setter hystrixOptions(Command command) {
    int concurrencyLimit = command.concurrencyLimit().orElse(10);
    return HystrixCommand.Setter
            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(command.name()))
            .andCommandKey(HystrixCommandKey.Factory.asKey(command.name()))
            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
                    .withExecutionIsolationStrategy(THREAD)
                    .withExecutionTimeoutInMilliseconds(1000))
            .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                    .withCoreSize(concurrencyLimit));
}
```
???
runs in a separate thread, because Hystrix must interrupt thread. You don't want to interrupt the whole request.

---
class: center, middle
# Circuit Breaking


---
class: codeonly
```java
class GetTotalLikesReaction implements Reaction<GetTotalLikes, TotalLikes> {

    @Override
    public TotalLikes react(GetTotalLikesReaction $) {
      try {
          TimeUnit.SECONDS.sleep(30);
      } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
      }
    }

```

--
```java
@FallsBackImmediatelyAfterThirdAttempt
private HystrixCommand.Setter hystrixOptions(Command command) {
    int concurrencyLimit = command.concurrencyLimit().orElse(10);
    return HystrixCommand.Setter
            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(command.name()))
            .andCommandKey(HystrixCommandKey.Factory.asKey(command.name()))
            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
*                   .withCircuitBreakerSleepWindowInMilliseconds(30000)
*                   .withCircuitBreakerRequestVolumeThreshold(2)
                    .withExecutionIsolationStrategy(THREAD)
                    .withExecutionTimeoutInMilliseconds(1000))
            .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                    .withCoreSize(concurrencyLimit));
}
```

---
class: center, middle
# You made it! Now books...

---
background-image:url(goodreads.png)
background-size: 100%

---
background-image:url(twitter.png)
background-size: 100%

---
background-image:url(books1.png)
background-size: 100%

---
background-image:url(books2.png)
background-size: 100%

---
background-image:url(wtw.png)
background-size: 100%

---
class: center, middle
# Final words

---
class: center, middle
# Thank you!



    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
    <script>
      var slideshow = remark.create({
        highlightLines: true,
        slideNumberFormat: function (current, total) { return "" }
      });
    </script>

  </body>
</html>
